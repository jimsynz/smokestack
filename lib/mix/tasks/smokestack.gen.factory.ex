defmodule Mix.Tasks.Smokestack.Gen.Factory do
  @moduledoc """
  Add a factory definition for a resource to your factory file.

  Generates a factory DSL entry for all current public attributes of the
  provided resource.

  ## Example

  ```bash
  mix smokestack.gen.factory Helpdesk.Support.Ticket \
    --variant default \
    --domain Helpdesk \
    --factory-module Helpdesk.Factory
  ```

  ## Options

  * `--variant` - Specify a variant name to use for the factory. Optional.
    Defaults to 'default'.
  * `--domain` - The domain module used to access the resource. Optional. If not
    specified it is inferred by removing the last segment from the resource
    name.
  * `--factory-module` - Specify the name of the factory module to generate.
    Optional. Defaults to one generated by adding `.Factory` to your app module.
  """

  @shortdoc "Generate a factory definition for a resource"
  alias Ash.Resource
  alias Sourceror.Zipper
  use Igniter.Mix.Task

  @impl Igniter.Mix.Task
  def info(_argv, _parent) do
    %Igniter.Mix.Task.Info{
      schema: [
        variant: :string,
        domain: :string,
        factory_module: :string
      ],
      aliases: [
        v: :variant,
        d: :domain,
        f: :factory_module
      ]
    }
  end

  @impl Igniter.Mix.Task
  def igniter(igniter, [resource | argv]) do
    resource = Igniter.Code.Module.parse(resource)
    options = options!(argv)

    variant =
      case options[:variant] do
        nil -> :default
        variant -> String.to_atom(variant)
      end

    domain =
      case options[:domain] do
        nil -> resource |> Module.split() |> List.delete_at(-1) |> Module.concat()
        domain -> Igniter.Code.Module.parse(domain)
      end

    factory_module =
      case options[:factory_module] do
        nil -> Igniter.Code.Module.module_name("Factory")
        module -> Igniter.Code.Module.parse(module)
      end

    igniter =
      igniter
      |> Igniter.compose_task("smokestack.gen.factory_module", [
        inspect(factory_module),
        "--ignore-if-exists"
      ])

    with {:ok, igniter} <- remove_no_factories_comment(igniter, factory_module),
         {:ok, igniter} <- add_factory(igniter, factory_module, resource, variant, domain) do
      igniter
    else
      {:error, igniter} -> raise igniter
    end
  end

  defp add_factory(igniter, factory_module, resource, variant, domain) do
    Igniter.Code.Module.find_and_update_module(igniter, factory_module, fn zipper ->
      with {:ok, zipper} <- maybe_move_past_existing_factories(zipper) do
        {:ok, do_add_factory(zipper, resource, variant, domain)}
      end
    end)
  end

  defp do_add_factory(zipper, resource, :default, domain) do
    Igniter.Code.Common.add_code(
      zipper,
      quote do
        factory unquote(resource) do
          # wat
        end
      end
    )
  end

  defp do_add_factory(zipper, resource, variant, domain) do
    Igniter.Code.Common.add_code(
      zipper,
      quote do
        factory unquote(resource), unquote(variant) do
          # wat
        end
      end
    )
  end

  defp maybe_move_past_existing_factories(zipper) do
    case Igniter.Code.Function.move_to_function_call_in_current_scope(zipper, :factory, [1, 2]) do
      {:ok, zipper} -> maybe_move_past_existing_factories(zipper)
      :error -> {:ok, zipper}
    end
  end

  defp remove_no_factories_comment(igniter, factory_module) do
    with {:ok, {igniter, source, zipper}} <-
           Igniter.Code.Module.find_module(igniter, factory_module) do
      new_quoted =
        zipper
        |> Zipper.topmost()
        |> Zipper.traverse_while(fn zipper ->
          case maybe_replace_node(zipper) do
            {:ok, zipper} -> {:halt, zipper}
            :noop -> {:cont, zipper}
          end
        end)
        |> Zipper.topmost()
        |> Zipper.node()

      new_source = Rewrite.Source.update(source, :quoted, new_quoted)
      {:ok, %{igniter | rewrite: Rewrite.update!(igniter.rewrite, new_source)}}
    end
  end

  defp maybe_replace_node(zipper) do
    case Zipper.node(zipper) do
      node when is_tuple(node) and is_list(elem(node, 1)) ->
        case node_without_no_factories_comment(node) do
          ^node -> :noop
          node -> {:ok, Zipper.replace(zipper, node)}
        end

      _ ->
        :noop
    end
  end

  defp node_without_no_factories_comment(node) do
    node
    |> maybe_remove_comments(:trailing_comments)
    |> maybe_remove_comments(:leading_comments)
  end

  defp maybe_remove_comments(node, field) do
    options = elem(node, 1)

    comments =
      options
      |> Keyword.get(field, [])
      |> Enum.reduce({[], nil}, fn
        comment, {comments, last_change_line} when comment.line == last_change_line + 1 ->
          # drop the comment line if it's subsequent to the one we already found
          {comments, comment.line}

        comment, {comments, nil} ->
          if comment.text =~ ~r/Define your factories here:/ do
            {comments, comment.line}
          else
            {[comment | comments], nil}
          end
      end)
      |> elem(0)
      |> Enum.reverse()

    node
    |> put_elem(1, Keyword.put(options, field, comments))
  end
end
